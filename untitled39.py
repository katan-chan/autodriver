# -*- coding: utf-8 -*-
"""Untitled39.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cQwfw8Rv3zx68QIycKJCkkPtr2T6WwQM
"""

import numpy as np
import networkx as nx
from typing import Dict


def generate_planar_traffic_data(
    n_nodes: int = 100,
    n_vehicles: int = 30,
    n_communities: int = 4,
    p_in: float = 0.9,     # xác suất giữ cạnh trong cùng cộng đồng
    p_out: float = 0.7,    # xác suất giữ cạnh khác cộng đồng
    bandwidth_low: int = 5,
    bandwidth_high: int = 20,
    time_factor_low: float = 30.0,   # hệ số thời gian thấp (giây / đơn vị khoảng cách)
    time_factor_high: float = 90.0,  # hệ số thời gian cao
    seed: int = 42,
    time_window_seconds: float = 300.0,  # cửa sổ thời gian 5 phút
) -> Dict[str, np.ndarray]:
    """
    Sinh dữ liệu giả cho bài toán giao thông:
    - Đồ thị phẳng (grid 2D) có cộng đồng, luôn liên thông.
    - Mỗi cạnh e có:
        B_e ~ Uniform{bandwidth_low, ..., bandwidth_high}  (nguyên)
        factor_e ~ Uniform[time_factor_low, time_factor_high]
        T_e = dist(u, v) * factor_e
    - Mỗi request có:
        origin, destination, start_time trong [0, time_window_seconds]
    Trả về duy nhất 1 dict.
    """
    rng = np.random.default_rng(seed)

    # =============== 1. Sinh đồ thị phẳng cơ bản ===============
    rows = int(np.floor(np.sqrt(n_nodes)))
    cols = int(np.ceil(n_nodes / rows))
    total_nodes = rows * cols

    G_grid = nx.grid_2d_graph(rows, cols)  # planar

    mapping = {}
    reverse_mapping = {}
    node_id = 0
    for i in range(rows):
        for j in range(cols):
            mapping[(i, j)] = node_id
            reverse_mapping[node_id] = (i, j)
            node_id += 1

    G = nx.Graph()
    for nid in range(min(total_nodes, n_nodes)):
        G.add_node(nid)

    for (u2, v2) in G_grid.edges():
        u = mapping[u2]
        v = mapping[v2]
        if u < n_nodes and v < n_nodes:
            G.add_edge(u, v)

    n_nodes = G.number_of_nodes()

    # =============== 2. Cộng đồng + xoá cạnh ===============
    node_community = np.zeros(n_nodes, dtype=int)
    cols_per_comm = max(1, cols // n_communities)
    for nid in range(n_nodes):
        i, j = reverse_mapping[nid]
        comm = min(j // cols_per_comm, n_communities - 1)
        node_community[nid] = comm

    # Lọc cạnh
    to_remove = []
    for u, v in list(G.edges()):
        cu, cv = node_community[u], node_community[v]
        prob = p_in if cu == cv else p_out
        if rng.random() > prob:
            to_remove.append((u, v))
    G.remove_edges_from(to_remove)

    # =============== 3. Đảm bảo liên thông ===============
    def ensure_connected(G_):
        while not nx.is_connected(G_):
            comps = list(nx.connected_components(G_))
            base = comps[0]
            for u in base:
                i, j = reverse_mapping[u]
                for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    ii, jj = i + di, j + dj
                    if (ii, jj) not in mapping:
                        continue
                    v = mapping[(ii, jj)]
                    if v < n_nodes and not G_.has_edge(u, v):
                        G_.add_edge(u, v)
                        break
                if nx.is_connected(G_):
                    break

    ensure_connected(G)

    # =============== 4. Gán toạ độ, B_e, T_e ===============
    node_coords = np.zeros((n_nodes, 2))
    for nid in range(n_nodes):
        i, j = reverse_mapping[nid]
        node_coords[nid] = [j, -i]

    edges = list(G.edges())
    m = len(edges)

    edge_u = np.zeros(m, dtype=int)
    edge_v = np.zeros(m, dtype=int)

    # B_e random nguyên, mỗi cạnh một giá trị
    edge_bandwidth = rng.integers(bandwidth_low, bandwidth_high + 1, size=m).astype(float)

    # factor_e random, mỗi cạnh một giá trị
    edge_time_factor = rng.uniform(time_factor_low, time_factor_high, size=m)
    edge_travel_time = np.zeros(m, dtype=float)

    adj_bandwidth = np.zeros((n_nodes, n_nodes), dtype=float)
    adj_travel = np.full((n_nodes, n_nodes), np.inf, dtype=float)

    for k, (u, v) in enumerate(edges):
        edge_u[k], edge_v[k] = u, v

        # dist trên grid
        du = node_coords[u] - node_coords[v]
        dist = float(np.linalg.norm(du))

        # travel time = dist * factor_e
        t = dist * edge_time_factor[k]
        edge_travel_time[k] = t

        B = edge_bandwidth[k]
        adj_bandwidth[u, v] = adj_bandwidth[v, u] = B
        adj_travel[u, v] = adj_travel[v, u] = t

    # =============== 5. Sinh request (5 phút) ===============
    origins = rng.integers(0, n_nodes, size=n_vehicles)
    destinations = rng.integers(0, n_nodes, size=n_vehicles)
    for i in range(n_vehicles):
        if origins[i] == destinations[i]:
            choices = np.setdiff1d(np.arange(n_nodes), [origins[i]])
            destinations[i] = rng.choice(choices)
    start_times = rng.uniform(0, time_window_seconds, size=n_vehicles)

    # =============== 6. Gói toàn bộ dữ liệu vào 1 dict duy nhất ===============
    data = dict(
        graph=G,
        node_coords=node_coords,
        node_community=node_community,
        edge_u=edge_u,
        edge_v=edge_v,
        edge_bandwidth=edge_bandwidth,
        edge_travel_time=edge_travel_time,
        edge_time_factor=edge_time_factor,
        adjacency_bandwidth=adj_bandwidth,
        adjacency_travel_time=adj_travel,
        vehicle_origin=origins,
        vehicle_destination=destinations,
        vehicle_start_time=start_times,
        vehicle_id=np.arange(n_vehicles),
        n_nodes=n_nodes,
        n_edges=m,
        n_vehicles=n_vehicles,
    )

    return data

import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots


def _generate_n_colors(num_colors: int) -> list:
    """
    Sinh num_colors màu khác nhau bằng cách chia đều trên vòng màu HSV.
    Trả về list hex string: ["#rrggbb", ...]
    """
    if num_colors <= 0:
        return []
    colors = []
    hues = np.linspace(0.0, 1.0, num_colors, endpoint=False)
    s = 0.6
    v = 0.9
    for h in hues:
        i = int(h * 6.0)
        f = h * 6.0 - i
        p = v * (1.0 - s)
        q = v * (1.0 - f * s)
        t = v * (1.0 - (1.0 - f) * s)
        i = i % 6
        if i == 0:
            r, g, b = v, t, p
        elif i == 1:
            r, g, b = q, v, p
        elif i == 2:
            r, g, b = p, v, t
        elif i == 3:
            r, g, b = p, q, v
        elif i == 4:
            r, g, b = t, p, v
        else:
            r, g, b = v, p, q
        R = int(r * 255)
        G = int(g * 255)
        B = int(b * 255)
        colors.append(f"#{R:02x}{G:02x}{B:02x}")
    return colors


def visualize_traffic_scenario_plotly_planar(
    data: dict,
    routes: np.ndarray,          # (n_vehicles, n_nodes), padded với -1
    show_vehicle_sample: int | None = None,  # None = vẽ toàn bộ
    node_size: int = 10,
):
    """
    Visualize kịch bản giao thông trên đồ thị phẳng + output routes.

    - Mỗi cạnh hiển thị nhãn: used/B
        + used = số route sử dụng cạnh đó
        + B    = edge_bandwidth

    - Cột trái: graph phẳng
        + Node xám
        + Edge xám, nhãn "used/B"
        + Mỗi request i (trong sample):
            * origin: triangle-up, màu riêng
            * dest  : triangle-down, cùng màu
            * route : polyline nối các node trong routes[i]

    - Cột phải: Gantt chart theo travel time:
        + Y = "req i"
        + X = [start, end], với end = start + tổng travel_time trên route.
    """
    G = data["graph"]
    n_nodes = int(data["n_nodes"])

    node_coords = data["node_coords"]
    edge_u = data["edge_u"]
    edge_v = data["edge_v"]
    edge_bandwidth = data["edge_bandwidth"]
    node_community = data["node_community"]
    origins = data["vehicle_origin"]
    destinations = data["vehicle_destination"]
    start_times = data["vehicle_start_time"]
    vehicle_id = data["vehicle_id"]
    adj_travel = data["adjacency_travel_time"]  # (n_nodes, n_nodes)

    n_vehicles = int(vehicle_id.shape[0])
    req_id = vehicle_id + 1  # đánh số request từ 1

    # safety check cho routes
    assert routes.shape[0] == n_vehicles, "routes.shape[0] phải = n_vehicles"

    # chọn sample request để vẽ trên graph
    if show_vehicle_sample is None or show_vehicle_sample >= n_vehicles:
        sample_idx = np.arange(n_vehicles)
    else:
        sample_idx = np.argsort(start_times)[:show_vehicle_sample]

    # ==========================
    # 0) Bảng màu per-request
    # ==========================
    max_rid = int(req_id.max())
    color_list = _generate_n_colors(max_rid)
    req_colors = {rid: color_list[rid - 1] for rid in range(1, max_rid + 1)}

    # ==========================
    # 0.5) Tính usage cho từng cạnh từ routes
    # ==========================
    from collections import defaultdict
    edge_usage_map = defaultdict(int)  # key = (min(u,v), max(u,v))

    for v in range(n_vehicles):
        seq = routes[v]
        seq = seq[seq >= 0]
        if seq.size < 2:
            continue
        for u_node, w_node in zip(seq[:-1], seq[1:]):
            u = int(u_node)
            w = int(w_node)
            if u == w:
                continue
            key = (u, w) if u < w else (w, u)
            edge_usage_map[key] += 1

    m = edge_u.shape[0]
    edge_usage = np.zeros(m, dtype=int)
    for idx, (u, v) in enumerate(zip(edge_u, edge_v)):
        key = (int(u), int(v)) if u < v else (int(v), int(u))
        edge_usage[idx] = edge_usage_map.get(key, 0)

    # ==========================
    # 1) Graph: nodes + edges
    # ==========================
    x_nodes = node_coords[:, 0]
    y_nodes = node_coords[:, 1]

    node_trace = go.Scatter(
        x=x_nodes,
        y=y_nodes,
        mode="markers",
        marker=dict(
            size=node_size,
            color="lightgray",
            line=dict(width=0.5, color="black"),
        ),
        text=[f"node {i}, comm {c}" for i, c in enumerate(node_community)],
        hoverinfo="text",
        name="nodes",
    )

    # Cạnh: màu xám + nhãn used/B
    edge_x, edge_y = [], []
    mid_x, mid_y, edge_text = [], [], []

    for u, v, B, used in zip(edge_u, edge_v, edge_bandwidth, edge_usage):
        x0, y0 = node_coords[u]
        x1, y1 = node_coords[v]
        edge_x += [x0, x1, None]
        edge_y += [y0, y1, None]

        mid_x.append((x0 + x1) / 2.0)
        mid_y.append((y0 + y1) / 2.0)
        edge_text.append(f"{int(used)}/{int(B)}")

    edge_lines_trace = go.Scatter(
        x=edge_x,
        y=edge_y,
        mode="lines",
        line=dict(width=2, color="lightgray"),
        hoverinfo="none",
        showlegend=False,
    )

    edge_label_trace = go.Scatter(
        x=mid_x,
        y=mid_y,
        mode="text",
        text=edge_text,
        textposition="top center",  # nhãn nằm phía trên cạnh
        textfont=dict(size=10, color="black", family="Arial Black"),
        hoverinfo="text",
        showlegend=False,
        name="usage/capacity",
    )

    # ==========================
    # 2) Request markers + ROUTES trên graph
    # ==========================
    request_graph_traces = []
    for idx in sample_idx:
        rid = int(req_id[idx])
        o = int(origins[idx])
        d = int(destinations[idx])
        color = req_colors[rid]
        group_name = f"req {rid}"

        # Route polyline (nếu có ít nhất 2 node hợp lệ)
        route_nodes = routes[idx]
        route_nodes = route_nodes[route_nodes >= 0]
        if route_nodes.size >= 2:
            x_route = node_coords[route_nodes, 0]
            y_route = node_coords[route_nodes, 1]
            route_trace = go.Scatter(
                x=x_route,
                y=y_route,
                mode="lines",
                line=dict(width=3, color=color),
                name=group_name,
                legendgroup=group_name,
                showlegend=False,
                hoverinfo="text",
                hovertext=[f"{group_name} path node {int(n)}" for n in route_nodes],
            )
            request_graph_traces.append(route_trace)

        # Origin: triangle-up, có legend
        origin_trace = go.Scatter(
            x=[node_coords[o, 0]],
            y=[node_coords[o, 1]],
            mode="markers",
            marker=dict(
                size=node_size * 1.9,
                symbol="triangle-up",
                color=color,
                line=dict(width=2, color="black"),
            ),
            name=group_name,
            legendgroup=group_name,
            showlegend=True,
            hovertext=[f"{group_name} origin: node {o} → dest node {d}"],
            hoverinfo="text",
        )

        # Destination: triangle-down
        dest_trace = go.Scatter(
            x=[node_coords[d, 0]],
            y=[node_coords[d, 1]],
            mode="markers",
            marker=dict(
                size=node_size * 1.9,
                symbol="triangle-down",
                color=color,
                line=dict(width=2, color="black"),
            ),
            name=group_name,
            legendgroup=group_name,
            showlegend=False,
            hovertext=[f"{group_name} dest: node {d} (origin {o})"],
            hoverinfo="text",
        )

        request_graph_traces.append(origin_trace)
        request_graph_traces.append(dest_trace)

    # ==========================
    # 3) Gantt chart theo travel_time
    # ==========================
    timeline_traces = []

    for v_idx, (rid, start) in enumerate(zip(req_id, start_times)):
        rid_int = int(rid)
        color = req_colors[rid_int]
        group_name = f"req {rid_int}"
        y_label = f"req {rid_int}"

        seq = routes[v_idx]
        seq = seq[seq >= 0]
        total_travel = 0.0
        if seq.size >= 2:
            for u_node, w_node in zip(seq[:-1], seq[1:]):
                u = int(u_node)
                w = int(w_node)
                total_travel += float(adj_travel[u, w])

        duration = total_travel
        end_time = start + duration

        # Nếu duration = 0 (không route / route rỗng), vẫn vẽ milestone mỏng
        if duration <= 0:
            duration = 1e-6  # thanh rất mỏng, coi như mốc

        bar = go.Bar(
            x=[duration],
            y=[y_label],
            base=[start],
            orientation="h",
            marker=dict(color=color),
            name=group_name,
            legendgroup=group_name,
            showlegend=False,  # legend ở graph
            hovertemplate=(
                "req %{y}<br>"
                "start=%{base:.1f}s<br>"
                "duration=%{x:.1f}s<br>"
                f"end={end_time:.1f}s"
                "<extra></extra>"
            ),
        )

        timeline_traces.append(bar)

    # ==========================
    # 4) Subplots & layout
    # ==========================
    fig = make_subplots(
        rows=1, cols=2,
        column_widths=[0.6, 0.4],
        subplot_titles=("Planar traffic graph", "Request Gantt chart (travel time)"),
    )

    # cột 1: graph phẳng
    fig.add_trace(edge_lines_trace, row=1, col=1)
    fig.add_trace(edge_label_trace, row=1, col=1)
    fig.add_trace(node_trace, row=1, col=1)
    for tr in request_graph_traces:
        fig.add_trace(tr, row=1, col=1)

    fig.update_xaxes(visible=False, row=1, col=1)
    fig.update_yaxes(visible=False, row=1, col=1)
    fig.update_yaxes(scaleanchor="x", scaleratio=1, row=1, col=1)

    # cột 2: Gantt chart
    for tr in timeline_traces:
        fig.add_trace(tr, row=1, col=2)

    fig.update_xaxes(title_text="time (s)", row=1, col=2)
    fig.update_yaxes(title_text="request", row=1, col=2, autorange="reversed")

    fig.update_layout(
        title="Planar traffic scenario – per-edge usage/capacity and per-request travel-time Gantt chart",
        barmode="stack",  # mỗi req một thanh riêng, không chồng nhau theo y
        legend=dict(
            orientation="v",
            yanchor="top",
            y=0.98,
            xanchor="left",
            x=1.02,
        ),
        height=650,
    )

    fig.show()

data = generate_planar_traffic_data(
    n_nodes=90,
    n_vehicles=30,
    n_communities=3,
    bandwidth_low = 5,
    bandwidth_high = 8,
    p_in=0.7,
    p_out=0.5,
    seed=42,
)

# fake routes: mỗi xe đi từ origin → dest bằng path ngắn nhất
G = data["graph"]
n_vehicles = data["n_vehicles"]
n_nodes = data["n_nodes"]
routes = -np.ones((n_vehicles, n_nodes), dtype=int)

for v in range(n_vehicles):
    s = int(data["vehicle_origin"][v])
    t = int(data["vehicle_destination"][v])
    path = nx.shortest_path(G, s, t)
    routes[v, :len(path)] = path

visualize_traffic_scenario_plotly_planar(
    data,
    routes,
    node_size=12,
)

import numpy as np
from numba import njit


@njit
def dijkstra_shortest_path(adjacency_travel_time: np.ndarray,
                           source: int,
                           target: int) -> tuple:
    """
    Dijkstra đơn giản O(n^2) trên ma trận kề:
    - adjacency_travel_time[u, v] = time (float) hoặc np.inf nếu không cạnh.
    Trả về:
    - total_cost: float
    - path: np.ndarray shape (n_nodes,), là chuỗi node từ source → target, padding -1.
    """
    n_nodes = adjacency_travel_time.shape[0]
    dist = np.full(n_nodes, np.inf)
    prev = np.full(n_nodes, -1, dtype=np.int64)
    visited = np.zeros(n_nodes, dtype=np.bool_)

    dist[source] = 0.0

    for _ in range(n_nodes):
        # Chọn node chưa visit có dist nhỏ nhất
        u = -1
        min_val = np.inf
        for i in range(n_nodes):
            if (not visited[i]) and (dist[i] < min_val):
                min_val = dist[i]
                u = i

        if u == -1:
            break
        if u == target:
            break

        visited[u] = True

        # Relax các neighbor
        row = adjacency_travel_time[u]
        for v in range(n_nodes):
            w = row[v]
            if w == np.inf:
                continue
            alt = dist[u] + w
            if alt < dist[v]:
                dist[v] = alt
                prev[v] = u

    # reconstruct path
    path = np.full(n_nodes, -1, dtype=np.int64)
    if dist[target] == np.inf:
        return dist[target], path

    tmp = np.full(n_nodes, -1, dtype=np.int64)
    idx = 0
    cur = target
    while cur != -1 and idx < n_nodes:
        tmp[idx] = cur
        cur = prev[cur]
        idx += 1

    # đảo lại tmp[0:idx] để thành path đúng thứ tự
    for i in range(idx):
        path[i] = tmp[idx - 1 - i]

    return dist[target], path


@njit
def compute_k_shortest_paths_for_vehicle(adjacency_travel_time: np.ndarray,
                                         source: int,
                                         target: int,
                                         k_paths: int,
                                         large_penalty: float) -> tuple:
    """
    Tính top-k path cho một chuyến:
    - Lần 1: Dijkstra trên adjacency_travel_time gốc.
    - Lần 2..k: sau mỗi path, cộng thêm large_penalty lên các cạnh
      thuộc path đó để "đẩy" thuật toán tìm path khác.
    Trả về:
    - costs[k_paths]
    - paths[k_paths, n_nodes]
    """
    n_nodes = adjacency_travel_time.shape[0]
    costs = np.full(k_paths, np.inf)
    paths = np.full((k_paths, n_nodes), -1, dtype=np.int64)

    # local copy để chỉnh penalty giữa các lần
    work_travel = adjacency_travel_time.copy()

    for k in range(k_paths):
        cost, path = dijkstra_shortest_path(work_travel, source, target)
        costs[k] = cost
        paths[k, :] = path

        # penalize các cạnh trên path này, để lần sau tìm đường khác
        for i in range(n_nodes - 1):
            u = path[i]
            v = path[i + 1]
            if v == -1:
                break
            if work_travel[u, v] < np.inf:
                work_travel[u, v] = work_travel[u, v] + large_penalty
                work_travel[v, u] = work_travel[v, u] + large_penalty

    return costs, paths


@njit
def compute_all_k_shortest_paths(adjacency_travel_time: np.ndarray,
                                 vehicle_origin: np.ndarray,
                                 vehicle_destination: np.ndarray,
                                 k_paths: int,
                                 large_penalty: float) -> tuple:
    """
    Tính top-k path cho toàn bộ chuyến.
    Trả về:
    - base_costs: (n_vehicles, k_paths)
    - all_paths:  (n_vehicles, k_paths, n_nodes)
    """
    n_vehicles = vehicle_origin.shape[0]
    n_nodes = adjacency_travel_time.shape[0]

    base_costs = np.full((n_vehicles, k_paths), np.inf)
    all_paths = np.full((n_vehicles, k_paths, n_nodes), -1, dtype=np.int64)

    for v in range(n_vehicles):
        s = int(vehicle_origin[v])
        t = int(vehicle_destination[v])
        costs_v, paths_v = compute_k_shortest_paths_for_vehicle(
            adjacency_travel_time, s, t, k_paths, large_penalty
        )
        for kk in range(k_paths):
            base_costs[v, kk] = costs_v[kk]
            for j in range(n_nodes):
                all_paths[v, kk, j] = paths_v[kk, j]

    return base_costs, all_paths


@njit
def build_edge_list_and_index(adjacency_bandwidth: np.ndarray) -> tuple:
    """
    Từ adjacency_bandwidth (n_nodes, n_nodes) sinh:
    - edge_u[m], edge_v[m], edge_bandwidth[m]
    - edge_index_matrix[n_nodes, n_nodes]: index cạnh hoặc -1.
    Giả định đồ thị vô hướng, chỉ lấy nửa trên (u < v).
    """
    n_nodes = adjacency_bandwidth.shape[0]

    # Đếm số cạnh
    m = 0
    for u in range(n_nodes):
        for v in range(u + 1, n_nodes):
            if adjacency_bandwidth[u, v] > 0.0:
                m += 1

    edge_u = np.full(m, 0, dtype=np.int64)
    edge_v = np.full(m, 0, dtype=np.int64)
    edge_bandwidth = np.zeros(m, dtype=np.float64)
    edge_index_matrix = np.full((n_nodes, n_nodes), -1, dtype=np.int64)

    idx = 0
    for u in range(n_nodes):
        for v in range(u + 1, n_nodes):
            if adjacency_bandwidth[u, v] > 0.0:
                edge_u[idx] = u
                edge_v[idx] = v
                edge_bandwidth[idx] = adjacency_bandwidth[u, v]
                edge_index_matrix[u, v] = idx
                edge_index_matrix[v, u] = idx
                idx += 1

    return edge_u, edge_v, edge_bandwidth, edge_index_matrix


@njit
def build_routes_from_choice(all_paths: np.ndarray,
                             chosen_k: np.ndarray) -> np.ndarray:
    """
    all_paths: (n_vehicles, k_paths, n_nodes)
    chosen_k:  (n_vehicles,), mỗi phần tử là index path được chọn [0..k_paths-1]
    Trả về:
    - routes: (n_vehicles, n_nodes)
    """
    n_vehicles = all_paths.shape[0]
    n_nodes = all_paths.shape[2]
    routes = np.full((n_vehicles, n_nodes), -1, dtype=np.int64)

    for v in range(n_vehicles):
        k_idx = chosen_k[v]
        for j in range(n_nodes):
            routes[v, j] = all_paths[v, k_idx, j]

    return routes


@njit
def compute_edge_loads_from_routes(routes: np.ndarray,
                                   edge_index_matrix: np.ndarray,
                                   n_edges: int) -> np.ndarray:
    """
    routes: (n_vehicles, n_nodes)
    edge_index_matrix[u, v] = index cạnh hoặc -1.
    Trả về:
    - edge_loads[m]: số route đi qua mỗi cạnh.
    """
    n_vehicles = routes.shape[0]
    n_nodes = routes.shape[1]
    edge_loads = np.zeros(n_edges, dtype=np.int64)

    for v in range(n_vehicles):
        seq = routes[v]
        # duyệt từng cặp liên tiếp
        for i in range(n_nodes - 1):
            u = seq[i]
            w = seq[i + 1]
            if w < 0:
                break
            e_idx = edge_index_matrix[u, w]
            if e_idx >= 0:
                edge_loads[e_idx] += 1

    return edge_loads


@njit
def compute_penalized_costs(all_paths: np.ndarray,
                            base_costs: np.ndarray,
                            penalty_edges: np.ndarray,
                            edge_index_matrix: np.ndarray) -> np.ndarray:
    """
    Tính cost_with_penalty cho mỗi (vehicle, k-path).
    - all_paths: (n_vehicles, k_paths, n_nodes)
    - base_costs: (n_vehicles, k_paths) (không penalty)
    - penalty_edges: (m,), penalty cho từng cạnh (e^P)
    - edge_index_matrix[u, v] = index cạnh hoặc -1

    Trả về:
    - penalized_costs: (n_vehicles, k_paths)
    """
    n_vehicles = all_paths.shape[0]
    k_paths = all_paths.shape[1]
    n_nodes = all_paths.shape[2]

    penalized_costs = np.zeros((n_vehicles, k_paths), dtype=np.float64)

    for v in range(n_vehicles):
        for kk in range(k_paths):
            path = all_paths[v, kk]
            base = base_costs[v, kk]
            if base == np.inf:
                penalized_costs[v, kk] = np.inf
                continue

            total = base
            for i in range(n_nodes - 1):
                u = path[i]
                w = path[i + 1]
                if w < 0:
                    break
                e_idx = edge_index_matrix[u, w]
                if e_idx >= 0:
                    total += penalty_edges[e_idx]

            penalized_costs[v, kk] = total

    return penalized_costs


@njit
def solve_routing_with_penalty(
    adjacency_travel_time: np.ndarray,
    adjacency_bandwidth: np.ndarray,
    vehicle_origin: np.ndarray,
    vehicle_destination: np.ndarray,
    k_paths: int = 3,
    max_iterations: int = 10,
    large_penalty_for_alt: float = 1e3,
) -> np.ndarray:
    """
    Giải bài toán gán tuyến với penalty băng thông.

    Input:
    - adjacency_travel_time: (n_nodes, n_nodes), np.inf nếu không có cạnh
    - adjacency_bandwidth:   (n_nodes, n_nodes), 0 nếu không có cạnh, B_e nếu có
    - vehicle_origin:        (n_vehicles,)
    - vehicle_destination:   (n_vehicles,)
    - k_paths:               số đường đi tốt nhất mỗi chuyến
    - max_iterations:        số vòng lặp penalty
    - large_penalty_for_alt: penalty lớn để ép Dijkstra tìm path khác (k-shortest)

    Output:
    - routes: (n_vehicles, n_nodes), mỗi hàng là path được chọn, padding -1.
    """
    n_nodes = adjacency_travel_time.shape[0]
    n_vehicles = vehicle_origin.shape[0]

    # 1) Tính top-k đường đi ngắn nhất cho mỗi chuyến (without penalty)
    base_costs, all_paths = compute_all_k_shortest_paths(
        adjacency_travel_time,
        vehicle_origin,
        vehicle_destination,
        k_paths,
        large_penalty_for_alt,
    )

    # 2) Sinh danh sách cạnh + index matrix
    edge_u, edge_v, edge_bandwidth, edge_index_matrix = build_edge_list_and_index(
        adjacency_bandwidth
    )
    n_edges = edge_u.shape[0]

    # 3) Khởi tạo: mỗi chuyến dùng path k=0 (ngắn nhất)
    chosen_k = np.zeros(n_vehicles, dtype=np.int64)

    # 4) Lặp cập nhật penalty + chọn path
    for it in range(max_iterations):
        # 4.1) Build routes từ chosen_k
        routes = build_routes_from_choice(all_paths, chosen_k)

        # 4.2) Tính tải trên từng cạnh
        edge_loads = compute_edge_loads_from_routes(
            routes, edge_index_matrix, n_edges
        )

        # 4.3) Tính overflow và penalty cạnh
        penalty_edges = np.zeros(n_edges, dtype=np.float64)
        for e in range(n_edges):
            B_e = edge_bandwidth[e]
            load_e = float(edge_loads[e])
            overflow = load_e - B_e
            if overflow > 0.0:
                penalty_edges[e] = np.exp(overflow)
            else:
                penalty_edges[e] = 0.0

        # 4.4) Tính cost_with_penalty cho toàn bộ (v, k)
        penalized_costs = compute_penalized_costs(
            all_paths, base_costs, penalty_edges, edge_index_matrix
        )

        # 4.5) Chọn k tốt nhất cho mỗi chuyến
        new_chosen_k = np.zeros(n_vehicles, dtype=np.int64)
        for v in range(n_vehicles):
            best_k = 0
            best_cost = penalized_costs[v, 0]
            for kk in range(1, k_paths):
                c = penalized_costs[v, kk]
                if c < best_cost:
                    best_cost = c
                    best_k = kk
            new_chosen_k[v] = best_k

        # 4.6) Nếu không thay đổi nữa thì dừng
        changed = False
        for v in range(n_vehicles):
            if new_chosen_k[v] != chosen_k[v]:
                changed = True
                break

        chosen_k = new_chosen_k

        if not changed:
            break

    # 5) Build routes cuối cùng
    routes_final = build_routes_from_choice(all_paths, chosen_k)
    return routes_final

data = generate_planar_traffic_data(
    n_nodes=90,
    n_vehicles=90,
    n_communities=3,
    p_in=0.7,
    p_out=0.5,
    bandwidth_low = 5,
    bandwidth_high = 6,
    seed=42,
)

routes = solve_routing_with_penalty(
    adjacency_travel_time=data["adjacency_travel_time"],
    adjacency_bandwidth=data["adjacency_bandwidth"],
    vehicle_origin=data["vehicle_origin"],
    vehicle_destination=data["vehicle_destination"],
    k_paths=3,
    max_iterations=10,
    large_penalty_for_alt=1e3,
)

# visualize bằng hàm plotly đã có:
visualize_traffic_scenario_plotly_planar(
    data,
    routes,
    node_size=12,
)